/**
 * This service obtains aggregated data from STH and
 * transforms it to get the format needed by MultibarChart Nvd3 component.
 */
myApp.service('aggrStringAttrSrv', function ($http, $q, $timeout) {
    //change this URL to ask to your own instance of sth-comet
    var sthUrl = 'http://localhost:8666/STH/v1/contextEntities',
        loadLocalData = true,
        RESOLUTIONS_MS = {
            second: 1000,
            minute: 60 * 1000,
            hour: 60 * 60 * 1000,
            day: 24 * 60 * 60 * 1000
        };

    /**
     * Get the Date (javascript) represented by originDate, resolution and offset.
     * @param {String} originDate string representation of the base date (in UTC!)
     * @param {String} resolution the unit of offset ['day', 'hour', 'minute', 'second']
     * @param {Number} offset number of days, hours, minutes, etc. from the origin (calculated in UTC!)
     * @return {Date} Date
     * @private
     */
    var _getDate = function(originDate, resolution, offset) {
        var date = new Date(originDate);

        if (resolution === 'day') {
            //originDate starts with day 1st
            return new Date(date.getUTCFullYear(), date.getUTCMonth(), offset);
        } else {
            return new Date(date.getTime() + offset * RESOLUTIONS_MS[resolution]);
        }

    };

    var _transposeAndFillGaps = function(samplesByDate, qualitativeValues) {
        var transposed = [], //ordered by qualitative values
            point,
            value,
            date;
        for (var i = 0; i < samplesByDate.length; i++) {
            point = samplesByDate[i];
            date = point[0];

            for (var j = 0; j < qualitativeValues.length; j++) {
                value = point[1][qualitativeValues[j]] || null;

                if (transposed[j]) {
                    transposed[j].values.push([date, value]);
                } else {
                    transposed.push({key: qualitativeValues[j], values: [[date, value]]});
                }
            }
        }

        return transposed;
    };

    /**
     * We need to transform the data generated by sth-comet to the format needed by MultiBarChart
     * 1.Points are aggregated by resolution in STH:
     *  values: [{resolution: "hour"
     *            origin: "2016-02-03T00:00:00.000Z"
     *            points: [p1, p2, p3]
     *           },
     *           {resolution:"hour"
     *            origin: "2016-02-04T00:00:00.000Z"
     *            points: [p1, p2, p3]
     *           },
     *
     * We need to flatten that matrix and get the date of each point.
     * We need to register the values of each point
     *
     * once we have: samplesByDate = [["2016/02/03-15:00", {"C.S":2, "C.F": 3"}],
     *                                ["2016/02/03-15:00", {"C.F": 1"}]]
     * and qualitativeValues = ["C.S", "C.F"]
     *
     * 2. We need to transpose the matrix and fill the gaps (every 'values' array must contain the same number of items.
     * This means to obtain this format:
     *  [{key: "C.S", values: [["2016/02/03-15:00", 2], ["2016/02/03-16:00", null]]},
     *   {key: "C.F", values: [["2016/02/03-15:00", 3], ["2016/02/03-16:00", 1]]}]
     *   This is the format needed by MultiBarChart
     */

    var _extractSamples = function(attrName, samplesList, aggrMethod) {
        var qualitativeValues = [], // the complete list of qualitative values found in samplesList
            samplesByDate = [], // a temporal convenience list of samples ordered by Date
            samplesByDateSlice, // the list of samples of a specific value ordered by Date
            points,
            date,
            point;

        var _registerQualitativeValues = function(v, k) {
            if (this.indexOf(k) < 0) {
                this.push(k);
            }
        };

        for (var i = 0; i < samplesList.length; i++) {
            samplesByDateSlice = [];
            points = samplesList[i].points;
            for (var j = 0; j < points.length; j++) {
                date = _getDate(samplesList[i]._id.origin,
                    samplesList[i]._id.resolution,
                    points[j].offset);
                point = [date, points[j][aggrMethod]];
                samplesByDateSlice.push(point); // same order
                angular.forEach(points[j][aggrMethod], _registerQualitativeValues, qualitativeValues);

            }
            samplesByDate = samplesByDate.concat(samplesByDateSlice);
        }

        return _transposeAndFillGaps(samplesByDate, qualitativeValues);
    };

    /**
     * Parses the response to get the samples in a proper format.
     * @param {Object} response
     * @param {string} reqAggrMethod {sum, occur...}
     * @return {Array} array of object
     * @private
     */
    var _parseSamples = function(response, reqAggrMethod) {
        var values = response.data.contextResponses[0].contextElement.attributes[0].values,
            attrName = response.data.contextResponses[0].contextElement.attributes[0].name;

        return _extractSamples(attrName, values, reqAggrMethod);
    };

    return {
        /**
         * Get the record of values aggregated by a period in a specific interval
         * @param {string} entityId
         * @param {string} entityType (optional)
         * @param {string} attr attribute name
         * @param {object} interval defines the dates range and the aggregation period and method.
         * @return {Array} array of objects with values. Each one representing a set of samples
         */
        getAggregated: function(entityId, entityType, attr, interval) {
            var deferred = $q.defer(),
                localResult,
                entityIdPath = (entityType) ? 'type/' + entityType + '/id/' + entityId : entityId,
                attrSamplesPath = '/' + entityIdPath + '/attributes/' + attr,
                attrSamplesUrl = sthUrl + attrSamplesPath,
                //change this parameters to ask your own query
                config = {
                    params: {
                        aggrMethod: 'occur',
                        aggrPeriod: interval.aggrPeriod,
                        dateFrom: interval.dateFrom.toISOString(),
                        dateTo: interval.dateTo.toISOString()
                    },
                    headers: {
                        'Fiware-Service': 'smartvalencia',
                        'Fiware-ServicePath': '/testAna'
                        //'X-Auth-Token': 'XXXXXXX'
                    }
                };

            if (loadLocalData) {
                localResult = {
                    method: config.params.aggrMethod,
                    data: _parseSamples({data: aggrDataByHour}, config.params.aggrMethod)
                };
                $timeout(function() {
                    deferred.resolve(localResult);
                });
                return deferred.promise;
            } else {

                return $http.get(attrSamplesUrl, config).then(function(response) {
                    return {
                        method: config.params.aggrMethod,
                        data: _parseSamples(response, config.params.aggrMethod)
                    };
                });
            }
        }
    };
})
